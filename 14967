{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please input the regex: ac*b \n"
     ]
    }
   ],
   "source": [
    "from collections import defaultdict\n",
    "from graphviz import Digraph, render\n",
    "\n",
    "star = '*'\n",
    "line = '|'\n",
    "dot = '·'\n",
    "leftBracket, rightBracket = '(', ')'\n",
    "alphabet = [chr(i) for i in range(ord('A'), ord('Z') + 1)] + \\\n",
    "    [chr(i) for i in range(ord('a'), ord('z') + 1)] + \\\n",
    "    [chr(i) for i in range(ord('0'), ord('9') + 1)]\n",
    "epsilon = 'ε'\n",
    "\n",
    "class FA:\n",
    "\n",
    "    def __init__(self, symbol = set([])):\n",
    "        self.states = set()\n",
    "        self.symbol = symbol    # input symbol \n",
    "        self.transitions = defaultdict(defaultdict)\n",
    "        self.startstate = None\n",
    "        self.finalstates = []\n",
    "\n",
    "    def setStart(self, state):\n",
    "        self.startstate = state\n",
    "        self.states.add(state)\n",
    "\n",
    "    def addFinal(self, state):\n",
    "        if isinstance(state, int):\n",
    "            state = [state]\n",
    "        for s in state:\n",
    "            if s not in self.finalstates:\n",
    "                self.finalstates.append(s)\n",
    "\n",
    "    def addTransition(self, fromstate, tostate, inputch):   # add only one \n",
    "        if isinstance(inputch, str):\n",
    "            inputch = set([inputch])\n",
    "        self.states.add(fromstate)\n",
    "        self.states.add(tostate)\n",
    "        if fromstate in self.transitions and tostate in self.transitions[fromstate]:\n",
    "            self.transitions[fromstate][tostate] = \\\n",
    "            self.transitions[fromstate][tostate].union(inputch)\n",
    "        else:\n",
    "            self.transitions[fromstate][tostate] = inputch\n",
    "\n",
    "    def addTransition_dict(self, transitions):  # add dict to dict \n",
    "        for fromstate, tostates in transitions.items():\n",
    "            for state in tostates:\n",
    "                self.addTransition(fromstate, state, tostates[state])\n",
    "\n",
    "    def newBuildFromNumber(self, startnum):\n",
    "    # change the states' representing number to start with the given startnum\n",
    "        translations = {}\n",
    "        for i in self.states:\n",
    "            translations[i] = startnum\n",
    "            startnum += 1\n",
    "        rebuild = FA(self.symbol)\n",
    "        rebuild.setStart(translations[self.startstate])\n",
    "        rebuild.addFinal(translations[self.finalstates[0]])\n",
    "        for fromstate, tostates in self.transitions.items():\n",
    "            for state in tostates:\n",
    "                rebuild.addTransition(translations[fromstate], translations[state], tostates[state])\n",
    "        return [rebuild, startnum]\n",
    "\n",
    "    def newBuildFromEqualStates(self, equivalent, pos):\n",
    "        # change states' number after merging\n",
    "        rebuild = FA(self.symbol)\n",
    "        for fromstate, tostates in self.transitions.items():\n",
    "            for state in tostates:\n",
    "                rebuild.addTransition(pos[fromstate], pos[state], tostates[state])\n",
    "        rebuild.setStart(pos[self.startstate])\n",
    "        for s in self.finalstates:\n",
    "            rebuild.addFinal(pos[s])\n",
    "        return rebuild\n",
    "\n",
    "    def getEpsilonClosure(self, findstate):\n",
    "        allstates = set()\n",
    "        states = [findstate]\n",
    "        while len(states):\n",
    "            state = states.pop()\n",
    "            allstates.add(state)\n",
    "            if state in self.transitions:\n",
    "                for tos in self.transitions[state]:\n",
    "                    if epsilon in self.transitions[state][tos] and \\\n",
    "                        tos not in allstates:\n",
    "                        states.append(tos)\n",
    "        return allstates\n",
    "\n",
    "    def getMove(self, state, skey):\n",
    "        if isinstance(state, int):\n",
    "            state = [state]\n",
    "        trstates = set()\n",
    "        for st in state:\n",
    "            if st in self.transitions:\n",
    "                for tns in self.transitions[st]:\n",
    "                    if skey in self.transitions[st][tns]:\n",
    "                        trstates.add(tns)\n",
    "        return trstates\n",
    "\n",
    "    def display(self, fname, pname):\n",
    "        fa = Digraph(pname, filename = fname, format = 'png')\n",
    "        fa.attr(rankdir='LR')\n",
    "\n",
    "        fa.attr('node', shape = 'doublecircle')\n",
    "        for fst in self.finalstates:\n",
    "            fa.node('s' + str(fst))\n",
    "\n",
    "        fa.attr('node', shape = 'circle')\n",
    "        for fromstate, tostates in self.transitions.items():\n",
    "            for state in tostates:\n",
    "                tmp = ''\n",
    "                for s in tostates[state]:\n",
    "                    tmp += s + '|'\n",
    "                fa.edge('s' + str(fromstate), 's' + str(state), label = tmp[:-1])\n",
    "\n",
    "        fa.attr('node', shape = 'point')\n",
    "        fa.edge('', 's' + str(self.startstate))\n",
    "\n",
    "        fa.view()\n",
    "\n",
    "class Regex2NFA:\n",
    "\n",
    "    def __init__(self, regex):\n",
    "        self.regex = regex\n",
    "        self.buildNFA()\n",
    "\n",
    "    def displayNFA(self):\n",
    "        self.nfa.display('nfa.gv', 'nondeterministic_finite_state_machine')\n",
    "\n",
    "    @staticmethod\n",
    "    def getPriority(op):\n",
    "        if op == line:\n",
    "            return 1\n",
    "        elif op == dot:\n",
    "            return 2\n",
    "        elif op == star:\n",
    "            return 3\n",
    "        else:       # left bracket \n",
    "            return 0\n",
    "\n",
    "    @staticmethod\n",
    "    def basicstruct(inputch):   # Regex = a -> NFA\n",
    "        state1 = 1\n",
    "        state2 = 2\n",
    "        basic = FA(set([inputch]))\n",
    "        basic.setStart(state1)\n",
    "        basic.addFinal(state2)\n",
    "        basic.addTransition(state1, state2, inputch)\n",
    "        return basic\n",
    "\n",
    "    @staticmethod\n",
    "    def linestruct(a, b):   # Regex = a | b -> NFA\n",
    "        [a, m1] = a.newBuildFromNumber(2)\n",
    "        [b, m2] = b.newBuildFromNumber(m1)\n",
    "        state1 = 1\n",
    "        state2 = m2\n",
    "        lineFA = FA(a.symbol.union(b.symbol))\n",
    "        lineFA.setStart(state1)\n",
    "        lineFA.addFinal(state2)\n",
    "        lineFA.addTransition(lineFA.startstate, a.startstate, epsilon)\n",
    "        lineFA.addTransition(lineFA.startstate, b.startstate, epsilon)\n",
    "        lineFA.addTransition(a.finalstates[0], lineFA.finalstates[0], epsilon)\n",
    "        lineFA.addTransition(b.finalstates[0], lineFA.finalstates[0], epsilon)\n",
    "        lineFA.addTransition_dict(a.transitions)\n",
    "        lineFA.addTransition_dict(b.transitions)\n",
    "        return lineFA\n",
    "\n",
    "    @staticmethod\n",
    "    def dotstruct(a, b):    # Regex = a · b -> NFA\n",
    "        [a, m1] = a.newBuildFromNumber(1)\n",
    "        [b, m2] = b.newBuildFromNumber(m1)\n",
    "        state1 = 1\n",
    "        state2 = m2 - 1\n",
    "        dotFA = FA(a.symbol.union(b.symbol))\n",
    "        dotFA.setStart(state1)\n",
    "        dotFA.addFinal(state2)\n",
    "        dotFA.addTransition(a.finalstates[0], b.startstate, epsilon)\n",
    "        dotFA.addTransition_dict(a.transitions)\n",
    "        dotFA.addTransition_dict(b.transitions)\n",
    "        return dotFA\n",
    "\n",
    "    @staticmethod\n",
    "    def starstruct(a):  # Regex = a* -> NFA\n",
    "        [a, m1] = a.newBuildFromNumber(2)\n",
    "        state1 = 1\n",
    "        state2 = m1\n",
    "        starFA = FA(a.symbol)\n",
    "        starFA.setStart(state1)\n",
    "        starFA.addFinal(state2)\n",
    "        starFA.addTransition(starFA.startstate, a.startstate, epsilon)\n",
    "        starFA.addTransition(starFA.startstate, starFA.finalstates[0], epsilon)\n",
    "        starFA.addTransition(a.finalstates[0], starFA.finalstates[0], epsilon)\n",
    "        starFA.addTransition(a.finalstates[0], a.startstate, epsilon)\n",
    "        starFA.addTransition_dict(a.transitions)\n",
    "        return starFA\n",
    "\n",
    "    def buildNFA(self):\n",
    "        tword = ''\n",
    "        pre = ''\n",
    "        symbol = set()\n",
    "\n",
    "        # explicitly add dot to the expression \n",
    "        for ch in self.regex:\n",
    "            if ch in alphabet:\n",
    "                symbol.add(ch)\n",
    "            if ch in alphabet or ch == leftBracket:\n",
    "                if pre != dot and (pre in alphabet or pre in [star, rightBracket]):\n",
    "                    tword += dot\n",
    "            tword += ch\n",
    "            pre = ch\n",
    "        self.regex = tword\n",
    "\n",
    "        # convert infix expression to postfix expression \n",
    "        tword = ''\n",
    "        stack = []\n",
    "        for ch in self.regex:\n",
    "            if ch in alphabet:\n",
    "                tword += ch\n",
    "            elif ch == leftBracket:\n",
    "                stack.append(ch)\n",
    "            elif ch == rightBracket:\n",
    "                while(stack[-1] != leftBracket):\n",
    "                    tword += stack[-1]\n",
    "                    stack.pop()\n",
    "                stack.pop()    # pop left bracket \n",
    "            else:\n",
    "                while(len(stack) and Regex2NFA.getPriority(stack[-1]) >= Regex2NFA.getPriority(ch)):\n",
    "                    tword += stack[-1]\n",
    "                    stack.pop()\n",
    "                stack.append(ch)\n",
    "        while(len(stack) > 0):\n",
    "            tword += stack.pop()\n",
    "        self.regex = tword\n",
    "\n",
    "        # build ε-NFA from postfix expression -NFA\n",
    "        self.automata = []\n",
    "        for ch in self.regex:\n",
    "            if ch in alphabet:\n",
    "                self.automata.append(Regex2NFA.basicstruct(ch))\n",
    "            elif ch == line:\n",
    "                b = self.automata.pop()\n",
    "                a = self.automata.pop()\n",
    "                self.automata.append(Regex2NFA.linestruct(a, b))\n",
    "            elif ch == dot:\n",
    "                b = self.automata.pop()\n",
    "                a = self.automata.pop()\n",
    "                self.automata.append(Regex2NFA.dotstruct(a, b))\n",
    "            elif ch == star:\n",
    "                a = self.automata.pop()\n",
    "                self.automata.append(Regex2NFA.starstruct(a))\n",
    "        self.nfa = self.automata.pop()\n",
    "        self.nfa.symbol = symbol\n",
    "\n",
    "class NFA2DFA:\n",
    "\n",
    "    def __init__(self, nfa):\n",
    "        self.buildDFA(nfa)\n",
    "\n",
    "    def displayDFA(self):\n",
    "        self.dfa.display('dfa.gv', 'deterministic_finite_state_machine')\n",
    "\n",
    "    def displayminDFA(self):\n",
    "        self.minDFA.display('mindfa.gv', 'min_deterministic_finite_state_machine')\n",
    "\n",
    "    def buildDFA(self, nfa):    # subset method \n",
    "        allstates = dict()  # visited subset\n",
    "        eclosure = dict()   # every state's ε-closure\n",
    "        state1 = nfa.getEpsilonClosure(nfa.startstate)\n",
    "        eclosure[nfa.startstate] = state1\n",
    "        cnt = 1 # the number of subset, dfa state id\n",
    "        dfa = FA(nfa.symbol)\n",
    "        dfa.setStart(cnt)\n",
    "        states = [[state1, dfa.startstate]] # unvisit\n",
    "        allstates[cnt] = state1\n",
    "        cnt += 1\n",
    "        while len(states):\n",
    "            [state, fromindex] = states.pop()\n",
    "            for ch in dfa.symbol:\n",
    "                trstates = nfa.getMove(state, ch)\n",
    "                for s in list(trstates):   \n",
    "                    if s not in eclosure:\n",
    "                        eclosure[s] = nfa.getEpsilonClosure(s)\n",
    "                    trstates = trstates.union(eclosure[s])\n",
    "                if len(trstates):\n",
    "                    if trstates not in allstates.values():\n",
    "                        states.append([trstates, cnt])\n",
    "                        allstates[cnt] = trstates\n",
    "                        toindex = cnt\n",
    "                        cnt += 1\n",
    "                    else:\n",
    "                        toindex = [k for k, v in allstates.items() if v  ==  trstates][0]\n",
    "                    dfa.addTransition(fromindex, toindex, ch)\n",
    "            for value, state in allstates.items():\n",
    "                if nfa.finalstates[0] in state:\n",
    "                    dfa.addFinal(value)\n",
    "            self.dfa = dfa\n",
    "\n",
    "    @staticmethod\n",
    "    def reNumber(states, pos):  # renumber the sets' number begin from 1\n",
    "        cnt = 1\n",
    "        change = dict()\n",
    "        for st in states:\n",
    "            if pos[st] not in change:\n",
    "                change[pos[st]] = cnt\n",
    "                cnt += 1\n",
    "            pos[st] = change[pos[st]]\n",
    "\n",
    "    def minimise(self): # segmentation \n",
    "        states = list(self.dfa.states)\n",
    "        tostate = dict(set()) # Move(every state, every symbol)\n",
    "\n",
    "        # initialization \n",
    "        for st in states:\n",
    "            for sy in self.dfa.symbol:\n",
    "                if st in tostate:\n",
    "                    if sy in tostate[st]:\n",
    "                        tostate[st][sy] = tostate[st][sy].union(self.dfa.getMove(st, sy))\n",
    "                    else:\n",
    "                        tostate[st][sy] = self.dfa.getMove(st, sy)\n",
    "                else:\n",
    "                    tostate[st] = {sy : self.dfa.getMove(st, sy)}\n",
    "                if len(tostate[st][sy]):\n",
    "                    tostate[st][sy] = tostate[st][sy].pop()\n",
    "                else:\n",
    "                    tostate[st][sy] = 0\n",
    "\n",
    "        equal = dict()  # state sets \n",
    "        pos = dict()    # record the set which state belongs to \n",
    "\n",
    "        # initialization 2 sets, nonterminal states and final states\n",
    "        equal = {1: set(), 2: set()}\n",
    "        for st in states:\n",
    "            if st not in self.dfa.finalstates:\n",
    "                equal[1] = equal[1].union(set([st]))\n",
    "                pos[st] = 1\n",
    "        for fst in self.dfa.finalstates:\n",
    "            equal[2] = equal[2].union(set([fst]))\n",
    "            pos[fst] = 2\n",
    "\n",
    "        unchecked = []\n",
    "        cnt = 3 # the number of sets\n",
    "        unchecked.extend([[equal[1], 1], [equal[2], 2]])\n",
    "        while len(unchecked):\n",
    "            [equalst, id] = unchecked.pop()\n",
    "            for sy in self.dfa.symbol:\n",
    "                diff = dict()\n",
    "                for st in equalst:\n",
    "                    if tostate[st][sy] == 0:\n",
    "                        if 0 in diff:\n",
    "                            diff[0].add(st)\n",
    "                        else:\n",
    "                            diff[0] = set([st])\n",
    "                    else:\n",
    "                        if pos[tostate[st][sy]] in diff:\n",
    "                            diff[pos[tostate[st][sy]]].add(st)\n",
    "                        else:\n",
    "                            diff[pos[tostate[st][sy]]] = set([st])\n",
    "                if len(diff) > 1:\n",
    "                    for k, v in diff.items():\n",
    "                        if k:\n",
    "                            for i in v:\n",
    "                                equal[id].remove(i)\n",
    "                                if cnt in equal:\n",
    "                                    equal[cnt] = equal[cnt].union(set([i]))\n",
    "                                else:\n",
    "                                    equal[cnt] = set([i])\n",
    "                            if len(equal[id]) == 0:\n",
    "                                equal.pop(id)\n",
    "                            for i in v:\n",
    "                                pos[i] = cnt\n",
    "                            unchecked.append([equal[cnt], cnt])\n",
    "                            cnt += 1\n",
    "                    break\n",
    "        if len(equal) == len(states):\n",
    "            self.minDFA = self.dfa\n",
    "        else:\n",
    "            NFA2DFA.reNumber(states, pos)\n",
    "            self.minDFA = self.dfa.newBuildFromEqualStates(equal, pos)\n",
    "\n",
    "    def Analysis(self, string):\n",
    "        string = string.replace('@', epsilon)\n",
    "        curst = self.dfa.startstate\n",
    "        for ch in string:\n",
    "            if ch == epsilon:\n",
    "                continue\n",
    "            st = list(self.dfa.getMove(curst, ch))\n",
    "            if len(st) == 0:\n",
    "                return False\n",
    "            curst = st[0]\n",
    "        if curst in self.dfa.finalstates:\n",
    "            return True\n",
    "        return False\n",
    "\n",
    "if __name__ == '__main__':\n",
    "\n",
    "    # using example\n",
    "    regex = input('Please input the regex: ')\n",
    "    a = Regex2NFA(regex)\n",
    "    a.displayNFA()\n",
    "\n",
    "    b = NFA2DFA(a.nfa)\n",
    "    b.displayDFA()\n",
    "    b.minimise()\n",
    "    b.displayminDFA()\n",
    "\n",
    "    while True:\n",
    "        try:\n",
    "            s = input('Please input a word to analysis (take @ as ε): ')\n",
    "            if b.Analysis(s):\n",
    "                print('Accepted')\n",
    "            else:\n",
    "                print('Unaccepted')\n",
    "        except EOFError:\n",
    "            break\n",
    "# ac*b            \n",
    "# b*|a(a|b)((a|b)(a|b))*\n",
    "# a(a|b)((a|b)(a|b))*|b(a|b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
